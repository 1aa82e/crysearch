CrySearch application TODO list by evolution536

------------------------------------------------------------------
Package:
- Update resource.h with new version number;
- SDK headers;
- CrySearchXX.lib file;
- Update wiki with changes for the release.
------------------------------------------------------------------

- Fix header (like LordPE does, virtual dump);
- Brute-force PID's to find out about hidden processes (detect hidden processes):
	- compare with regular process list, to see if there actuall are hidden ones?
	- Also multi-thread...
- Revise memory scanner using bitset on disk (when u++ implements proper methods);
- Also blocks for the values and using compression/encoding to reduce size?
- Current way of disassembling may cause inconsistencies;
	- different disassembler, capstone?
	- Temporarely fixed by 1 thread.
- Still need to fix shitloads of stuff in the import table parser, sanity checks missing everywhere;
- release notes - buffer overruns;
- Bug in import table parser, x64, when switching from slack to winamp!

- In disassembly, we can drastically reduce memory usage by only using byte offets to the previous disassembly entry:
	- exponential time solution though!
- Guessing for pointer can be done by checking whether it is inside a memory page of the process?

- Follow pointer, many need it!
- let's build C++11/14 code from the current, and try to reduce the application size!
- Provide the output window / menu bar entry (PLUGIN_WANTS_OUTPUT_TAB);

- Track control flow of entire process and build it a tree!

- Debugger:
	- Software bp not correctly removed in Far Cry;
	- 16-byte registers during snapshot?
	- VEH debugger

- Structure dissections:
	- type guessing;
	- data schema (smth like xsd but for memory dissections);
	- generate struct definition from selection;

- Identify static addresses:
	- Generate C++ Fields / Struct / Union;
	- Expand to be used with pointers, maybe structs;

- Opening PDB files to navigate through disassembly with symbols, or just view symbols?

- Disassembler:
	- Follow unconditional jumps (draw arrow to the left of the disasm if in same page);

- Plugin system:
	- Plugin-events that are generated by plugins;
	- auto deploy correct plugins to build dir?
	- Plugin DLL to override process opening sequence; (maybe other templates)
	- Plugins have access to a menu in-app;

- VTable finder / dissection (learn_more, maybe a plugin);
- Find class instances based on a vtable;
- Dump .NET modules?
- Detect handles that are 'malicious'?
- Allow entering string as argument for create thread (let's make a custom data type of it);

- Main window:
	- Use right toolbar space for message queue:
		- Warning messages:
			- PE Headers may be destroyed (process open);
			- Executable module of process was hidden, undefined behavior;
			- Plugin(s) failed to load;
		- Info messages:
			- Could be anything...

- Encryption in target process & hide CrySearch from signature scan
	- Look at AesStream example in bazaar;
	- Metamorphic code.

- Winsock analysis, debugging packages sent/received;
- Pointer scan;

- Module window:
	- Manual mapper for x86 and x64;
	- QueueUserAPC;
	- ntdll.dll proces injection (LdrLoadDll,LdrpLoadDll).

- Code generation:
	- Configure Microsoft Visual C++ compiler to compile generated code?

- Scan for hooked functions inside a process based on:
	- Detours;
	- IAT.
	
- Code caves scanning;
- Write x86 driver using WinDDK (.sys) and create UI module to load it:
	- OpenProcess driver level equivalent;
	- Read/Write- ProcessMemory driver level equivalent;
	- TerminateThread driver level equivalent;

------------------------------------------------------------------------------------------------

Additions to U++:

Add this to the CoWork class:

	void SetThreadPriority(const int Priority)
	{
		Array<Thread>& thpPool = this->GetPool().threads;
		
		switch (Priority)
		{
			case 0:
				for (int thCount = 0; thCount < thpPool.GetCount(); thCount++)
				{
					thpPool[thCount].Priority(25);
				}
				break;
			case 1:
				for (int thCount = 0; thCount < thpPool.GetCount(); thCount++)
				{
					thpPool[thCount].Priority(75);
				}
				break;
			case 2:
				for (int thCount = 0; thCount < thpPool.GetCount(); thCount++)
				{
					thpPool[thCount].Priority(125);
				}
				break;
			case 3:
				for (int thCount = 0; thCount < thpPool.GetCount(); thCount++)
				{
					thpPool[thCount].Priority(175);
				}
				break;
			case 4:
				for (int thCount = 0; thCount < thpPool.GetCount(); thCount++)
				{
					thpPool[thCount].Priority(200);
				}
				break;
		}
	};

Add this line to the TabCtrl::Item class:

	const String&  GetText() const 					{ return text; }

Add this to the Bits class:

	// Added by evolution536 to enable reading out the buffer for storage.
	Bits(const dword* buffer, const int alloc)
	{
		this->bp = buffer;
		this->alloc = alloc;
	};
	
	const dword* const GetBuffer() const	{ return this->bp; }
	const int GetAlloc() const				{ return this->alloc;}

------------------------------------------------------------------------------------------------

- Log.cpp: Comment out GetUserNameA calls and OutputDebugString calls;
- App.h: Comment out GetUserName function;
- App.cpp: Comment out GetUserName function;
- ArrayCtrl.h: Move cellInfo variable in to protected;
- Ctrl.iml: Remove networking icon(s).

Copy uppsrc-custom files to designated locations before upp build.
